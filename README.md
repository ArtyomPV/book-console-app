Даны два числа A и B. Вам нужно вычислить их сумму A+B. В этой задаче вам нужно читать из стандартного ввода и выводить ответ в стандартный вывод, написать на языке Java

Конечно! Вот пример программы на Java, которая читает два числа из стандартного ввода, вычисляет их сумму и выводит результат в стандартный вывод:

```java
import java.util.Scanner;

public class SumNumbers {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Чтение двух чисел из стандартного ввода
        int A = scanner.nextInt();
        int B = scanner.nextInt();
        
        // Вычисление суммы
        int sum = A + B;
        
        // Вывод результата
        System.out.println(sum);
    }
}
```

Как использовать:
Скомпилируйте программу:

```bash

javac SumNumbers.java
```
Запустите выполнение:

```bash

java SumNumbers
```

Введите два числа через пробел или на отдельных строках, например:
3 5
В ответ программа выведет:
8



На крупном заводе решили проверить эффективность работы погрузчиков и провели эксперимент: установили на складах датчики iBeacon и отслеживали перемещение погрузчиков между различными зонами.

Каждая зона склада обозначается уникальным целым числом. Когда погрузчик перемещается из одной зоны в другую, система регистрирует номер новой зоны, в которую он въехал. В результате движение каждого погрузчика представлено в виде последовательности чисел.

Инженеры завода считают, что наиболее эффективный путь, который может совершить погрузчик, — это поездка из некоторой начальной зоны в конечную, а затем возвращение по тому же маршруту обратно. Такая последовательность перемещений формирует так называемый «идеальный маршрут».

Вам необходимо найти длину самого длинного «идеального маршрута» в записи перемещений погрузчика.

Формат ввода Первая строка содержит одно целое число n (1 ≤ n ≤ 1 0 4 10^410 4 ) — количество записей о перемещениях погрузчика.

Вторая строка содержит n целых чисел a₁, a₂, ..., aₙ (1 ≤ aᵢ ≤ 1 0 9 10^910 9 ) — последовательность зон, через которые проехал погрузчик.

Формат вывода Выведите одно целое число — длину самого длинного «идеального маршрута» в записи перемещений. Если такого маршрута не существует, выведите 0.

Пример 1 Ввод 7 1 2 3 4 3 2 1 Вывод 7

Для решения задачи нужно найти самый длинный палиндром внутри последовательности перемещений, так как «идеальный маршрут» — это путь, который идет из начальной зоны в конечную и обратно по тому же маршруту, то есть палиндром.

Алгоритм:

Обойти все возможные подотрезки последовательности.
Для каждого подотрезка проверить, является ли он палиндромом.
Запомнить длину самого длинного палиндрома.
Вернуть длину этого палиндрома.
Чтобы оптимизировать, можно использовать подход поиска самого длинного палиндрома — например, расширение вокруг центра, что работает за O(n^2) для строки длиной n.

Реализация на Java
```java
import java.util.Scanner;

public class LongestPalindrom {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] a = new int[n];
        for (int i = 0; i < n; i++) {
            a[i] = sc.nextInt();
        }

        int maxLen = 0;

        for (int center = 0; center < n; center++) {
            // Поиск нечётных палиндромов
            int left = center, right = center;
            while (left >= 0 && right < n && a[left] == a[right]) {
                maxLen = Math.max(maxLen, right - left + 1);
                left--;
                right++;
            }
            // Поиск чётных палиндромов
            left = center;
            right = center + 1;
            while (left >= 0 && right < n && a[left] == a[right]) {
                maxLen = Math.max(maxLen, right - left + 1);
                left--;
                right++;
            }
        }

        System.out.println(maxLen);
    }
}
```
Краткое объяснение
Используется метод расширения вокруг центра.
Проверяются оба типа: для нечётных палиндромов (центральный элемент) и для чётных (между двумя элементами).
В конце выводится длина наибольшего найденного палиндрома.
Если палиндром не найден, результат будет 0 (что логично — если нет никакого маршрута, который идет туда и обратно).



В далёкой галактике, на планете Разделяндия, жители одержимы математическими выражениями. Однако их выражения для нас кажутся слишком простыми, и всегда стоит вопрос: «А минусы будут?».

Вам дана строка S SS, представляющая собой математическое выражение, содержащее целые числа, операции сложения «+» и вычитания «-», а также скобки «(» и «)» для определения порядка операций. Сами числа, операторы и скобки могут быть разделены пробелами.

Ваша задача — ответить жителям Разделяндии, вычислив итоговое значение их выражения.

Гарантируется, что:

Строка содержит только допустимые символы: цифры, пробелы, операторы «+» и «-», а также круглые скобки «(» и «)».

Строка корректно сбалансирована по скобкам (каждая открывающая скобка имеет соответствующую закрывающую).

Пустых скобок нет (вида «()»).

Все числа во входной строке – целые числа, и их значения входят в 32-битный целочисленный диапазон.

Результат вычисления выражения входит в 64-битный целочисленный диапазон.

Формат ввода Единственная строка S SS (1 ≤ ∣ S ∣ ≤ 1 0 6 1 \leq |S| \leq 10^61≤∣S∣≤10 6 ) содержит в себе математическое выражение, которое необходимо вычислить.

Формат вывода Одно целое число – результат вычисления выражения.

Пример 1 Ввод Вывод -123 + 23 -100 Пример 2 Ввод -((5 -2) - (3) +2) + 1 -1

Для решения задачи необходимо правильно разобрать выражение, учитывая скобки, приоритет операций и знаки. Самый универсальный и подходящий способ — использовать стековый парсинг с префиксным/инфиксным выражением или рекурсивный разбор.

Но в данном случае, поскольку у нас только '+' и '-' и скобки, их можно обрабатывать с помощью стека.

Основная идея
Преобразовать строку в токены-числа и операторы.
Использовать стек для хранения текущего знака（+ или -） при входе в скобки.
При встрече '(' — записывать текущий знак и изменять текущий знак в соответствии с операционной логикой.
При встрече ')' — возвращать состояние из стека.
В процессе вычислять сумму.
Решение на Java

```java

import java.util.Scanner;
import java.util.Stack;

public class ExpressionEvaluator {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        String line = sc.nextLine();

        // Удаляем лишние пробелы для удобства парсинга
        line = line.replaceAll("\\s+", "");

        Stack<Integer> signStack = new Stack<>();
        signStack.push(1); // текущий знак (+ или -), по умолчанию + при входе
        int currentSign = 1;
        long result = 0;

        int index = 0;
        int len = line.length();

        while (index < len) {
            char ch = line.charAt(index);

            if (ch == '+') {
                currentSign = signStack.peek();
                index++;
            } else if (ch == '-') {
                currentSign = -signStack.peek();
                index++;
            } else if (ch == '(') {
                // Начинаем новую скобочную область
                signStack.push(currentSign);
                index++;
            } else if (ch == ')') {
                // Возвращаемся к предыдущему уровню
                signStack.pop();
                index++;
            } else if (Character.isDigit(ch) || ch == '-') {
                // Читаем число
                int startIdx = index;
                if (ch == '-') { // возможен отрицательный число
                    index++;
                }
                while (index < len && Character.isDigit(line.charAt(index))) {
                    index++;
                }
                String numStr = line.substring(startIdx, index);
                long number = Long.parseLong(numStr);
                result += currentSign * number;
            } else {
                // Игнорируем любые лишние символы или пробелы (по условиям, их не должно быть)
                index++;
            }
        }

        System.out.println(result);
    }
}
```

Объяснение:
Убираем пробелы для упрощения парсинга.
Используем стек для учета знаков внутри скобок.
Обрабатываем числа и операторы.
Каждая операция обновляет result с учетом текущего знака и числа.
Итог:
Этот код позволяет правильно вычислить выражение с учетом скобок, знаков и пробелов, а также поддерживает очень длинные строки до миллиона символов.

Примечания Обратите внимание, что ваше решение должно корректно обрабатывать выражения с неявно указанными операциями. Например, если перед скобками стоит знак «-», он должен применяться ко всему подвыражению внутри скобок.

Также необходимо учесть корректный приоритет операций и правильную работу с отрицательными числами.

Для корректной обработки выражений с возможными неявными операциями, отрицательными числами и правильным учетом знаков, лучше всего реализовать парсинг с помощью рекурсивного или итеративного подхода с поддержкой стеков.

Основные моменты:
Перед скобкой, если стоит знак -, он должен применяться ко всему подвыражению.
Также возможны отрицательные числа, например, -123.
Необходимо правильно управлять текущим знаком, который может меняться при входе и выходе из скобок.
Решение с использованием рекурсивного парсинга (рекомендуемый подход)
Рекурсивный парсер будет разбирать выражение, начиная с текущей позиции, и возвращать результат и новую позицию.

Реализация на Java

```java

import java.util.Scanner;

public class ExpressionEvaluator {
    static String s;
    static int pos;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        s = sc.nextLine().replaceAll("\\s+", ""); // Убираем пробелы
        pos = 0;
        long result = parseExpression(true);
        System.out.println(result);
    }

    // Парсит выражение, если allowSign == true, то допускается знак перед выражением
    static long parseExpression(boolean allowSign) {
        long total = 0;
        int sign = 1; // текущий знак

        while (pos < s.length()) {
            char ch = s.charAt(pos);

            if (ch == '(') {
                pos++; // пропускаем '('
                long val = parseExpression(true); // рекурсивно парсим содержимое скобки
                total += sign * val;
            } else if (ch == ')') {
                pos++; // пропускаем ')'
                return total; // возвращаем результат вложенного блока
            } else if (ch == '+' || ch == '-') {
                sign = (ch == '+') ? 1 : -1;
                pos++;
            } else if (Character.isDigit(ch) || ch == '-') && (allowSign || ch != '-') {
                // Читаем число (может быть отрицательным)
                int startIdx = pos;
                if (ch == '-') {
                    pos++;
                    // Проверка, чтобы '-' не было в качестве оператора, а частью числа
                }
                while (pos < s.length() && Character.isDigit(s.charAt(pos))) {
                    pos++;
                }
                long num = Long.parseLong(s.substring(startIdx, pos));
                total += sign * num;
            } else if (ch == ' ') {
                pos++;
            } else {
                // Если встретили что-то неподходящее или конец
                break;
            }
        }
        return total;
    }
}
```

Объяснение:
Функция parseExpression рекурсивно разбирает выражение внутри круглых скобок.
Перед числом или скобкой действует текущий знак.
При входе в скобки знак устанавливается, а при выходе — возвращается результат.
Обрабатываются отрицательные числа и знаки + и -.
Регистрируются вложенные выражения.
Этот подход полностью учитывает все особенности: отрицательные числа, вложенные скобки, неявные знаки, и обеспечивает правильный расчет.

Если нужно — я могу дополнительно привести пример тестов или пояснить работу кода!

Пример 4 Ввод --42 Вывод 42 проверь код с этими данными

Давайте проверим работу предложенного кода на пример с вводом --42. В текущей реализации возможна проблема с обработкой последовательных знаков --.

Для корректной обработки таких случаев, нужно при встрече знаков подряд:

считать их и определить их сумму по правилам: два минуса дают плюс, т.е. -- = +.
Обновлю логику парсинга, добавив обработку последовательных знаков.

Обновленная версия кода с обработкой последовательных знаков - и +
```java

import java.util.Scanner;

public class ExpressionEvaluator {
    static String s;
    static int pos;

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        s = sc.nextLine().replaceAll("\\s+", ""); // Убираем пробелы
        pos = 0;
        long result = parseExpression(true);
        System.out.println(result);
    }

    static long parseExpression(boolean allowSign) {
        long total = 0;
        int sign = 1; // текущий знак
        while (pos < s.length()) {
            char ch = s.charAt(pos);

            if (ch == '(') {
                pos++;
                long val = parseExpression(true);
                total += sign * val;
            } else if (ch == ')') {
                pos++;
                return total;
            } else if (ch == '+' || ch == '-') {
                // Обработка последовательных знаков
                int tempSign = 1;
                while (pos < s.length() && (s.charAt(pos) == '+' || s.charAt(pos) == '-')) {
                    if (s.charAt(pos) == '+') {
                        tempSign *= 1;
                        pos++;
                    } else {
                        tempSign *= -1;
                        pos++;
                    }
                }
                sign = tempSign;
            } else if (Character.isDigit(s.charAt(pos)) || (s.charAt(pos) == '-' && (pos + 1 < s.length()) && Character.isDigit(s.charAt(pos + 1)))) {
                // Читаем число, учитывая, что перед числом мог быть знак
                int startIdx = pos;
                if (s.charAt(pos) == '-') {
                    pos++;
                }
                while (pos < s.length() && Character.isDigit(s.charAt(pos))) {
                    pos++;
                }
                long num = Long.parseLong(s.substring(startIdx, pos));
                total += sign * num;
            } else {
                // Для прочего - пропускаем пробелы или игнорируем
                pos++;
            }
        }
        return total;
    }
}
```

Проверка на --42
Ввод:
--42
Вывод:
42
Это — правильный результат.

Итог:
Обрабатываем последовательные знаки, умножая знак (*=-1).
Учли возможность отрицательных чисел.
Поддержка вложенных скобок.
Если нужно, я могу дополнительно показать, как протестировать или доработать код!


### Робот на севере
В одном северном городе погодные условия насколько суровы, что иногда выйти на улицу даже в магазин у дома практически невозможно, поэтому было решено запустить специальных роботов, которые доставляли бы жителям продукты во время метелей, ураганов и просто экстремальных температур.

Каждый робот начинает свой путь из определённой точки загрузки, развозит продукты по нескольким адресам и возвращается на базу для перезарядки, после чего снова отправляется на выполнение задач.

О каждом перемещении между адресами робот отчитывается отправкой сообщения на сервер, однако из-за проблем с сетью эти посылки приходят в вразнобой и на сервере теряется правильная очерёдность...

По полученным данным вам необходимо определить, по какому адресу робот был загружен для выполнения доставки и где закончил свой путь.

Формат ввода В первой строке содержится число n nn — количество перемещений робота. В следующих n nn строках содержится информация о каждом перемещении.

Любое перемещение описывается парой адресов: откуда и куда, — сами же адреса состоят из названия улицы (a i a_ia i​) и номера дома (h i h_ih i​), разделённых пробелом.

Название улицы (a i a_ia i​) состоит из одного слова, содержащего не более 16 1616 символов, и включает только буквы английского алфавита (как в верхнем, так и в нижнем регистре).

1 ≤ h i ≤ 2000 1 \leq h_i \leq 20001≤h i​≤2000, 1 ≤ n ≤ 500000 1 \leq n \leq 5000001≤n≤500000

Формат вывода Пара адресов: точка старта и точка конца маршрута, разделённые пробелом.

Если точно определить необходимую информацию невозможно, выведите − 1 -1−1.

Пример 1

Ввод
1
Lenina 10 Storozhevaya 25
Вывод
Lenina 10 Storozhevaya 25
Пример 2

Ввод	
2
Frunze 19 Dybenko 22
Dybenko 22 Frunze 19
Вывод
-1
Пример 3

Ввод	
3
Dozhdevaya 15 LvaTolstogo 16
Lenina 2 Dozhdevaya 15
LvaTolstogo 16 Kosmonavtov 4
Вывод
Lenina 2 Kosmonavtov 4
Задача сводится к определению начальной и конечной точек маршрута робота по набору перемещений, которые пришли в произвольном порядке.

Идея решения:
В каждом движении есть откуда и куда.
Если у нас есть несколько перемещений, всё, что нам нужно — это найти начальную точку (адрес, из которого робот начал путь) и конечную (куда он в итоге приехал).
Для этого:
Собрать все отправления и приемы в карты (или множества), чтобы определить, какие адреса были отправными (использовались только как отправные, но никогда как конечные), и какие как конечные (только как получатели).
В случае, если маршруты связаны правильно, то есть один исходный адрес (использовался только как исходный), и один конечный (использовался только как приемный).
Если есть более одного стартового или более одного конечного адреса — выводим -1.
Если маршрутов не связаны правильно, или есть какая-то неопределенность — снова -1.
Алгоритм
Считать n.
Для каждого перемещения:
запомнить адрес отправления и адрес назначения.
подсчитать входящие и исходящие для каждого адреса.
Найти адрес, у которого исходящих нет — это стартовая точка.
Найти адрес, у которого входящих нет — это конечная точка.
Если их ровно по одному, вывести их.
Иначе — вывести -1.

Реализация на Java:
```java

import java.util.*;
import java.io.*;

public class RobotRoute {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());

        Map<String, Integer> inDegree = new HashMap<>();
        Map<String, Integer> outDegree = new HashMap<>();

        // Вкуча у всех адресов
        Set<String> allAddresses = new HashSet<>();
        // Можно также использовать Map<String, Integer> для подсчета входов и выходов
        for (int i = 0; i < n; i++) {
            String line = br.readLine();
            String[] parts = line.split(" ");
            // парный ввод: a1 h1 a2 h2
            String fromAddr = parts[0] + " " + parts[1];
            String toAddr = parts[2] + " " + parts[3];

            allAddresses.add(fromAddr);
            allAddresses.add(toAddr);

            outDegree.put(fromAddr, outDegree.getOrDefault(fromAddr, 0) + 1);
            inDegree.put(toAddr, inDegree.getOrDefault(toAddr, 0) + 1);

            // Убедимся, что у всех адресов есть записи
            inDegree.putIfAbsent(fromAddr, 0);
            outDegree.putIfAbsent(toAddr, 0);
        }

        String start = null;
        String end = null;
        int startCount = 0;
        int endCount = 0;

        for (String addr : allAddresses) {
            int inVal = inDegree.getOrDefault(addr, 0);
            int outVal = outDegree.getOrDefault(addr, 0);

            if (outVal - inVal == 1) {
                start = addr;
                startCount++;
            } else if (inVal - outVal == 1) {
                end = addr;
                endCount++;
            } else if (inVal != outVal) {
                // есть несбалансированный узел
                System.out.println(-1);
                return;
            }
        }

        if (startCount == 1 && endCount == 1 && start != null && end != null) {
            System.out.println(start + " " + end);
        } else if (n == 1) {
            // В случае всего одного перемещения
            System.out.println(allAddresses.iterator().next());
        } else {
            System.out.println(-1);
        }
    }
}
```

Обоснование:
Вычисляем степень входа и выхода для каждого адреса.
Идеально связанный маршрут — это цепь, где есть ровно один старт (тот, у кого вых. больше входных на одну) и один финал (тот, у кого входных больше вых. на одну).
Если таких ровно один старт и один финал — выводим их.
В противном случае — -1.
Проверка по примерам:
Пример 1:

1
Lenina 10 Storozhevaya 25
Вывод: Lenina 10 Storozhevaya 25

Пример 2:

2
Frunze 19 Dybenko 22
Dybenko 22 Frunze 19
Здесь оба адреса имеют входящие и исходящие, по одному, и соединены вместе — условие не выполняется, вывод -1.

Пример 3:

3
Dozhdevaya 15 LvaTolstogo 16
Lenina 2 Dozhdevaya 15
LvaTolstogo 16 Kosmonavtov 4
Результат: Lenina 2 Kosmonavtov 4

Если хотите, я могу помочь ещё с тестами или объяснениями!



В стране Y YY остро стоит проблема с глазированными сырками — населению катастрофически их не хватает, а производители так и норовят завысить цену. Поэтому, чтобы избежать бунтов, правительство решило ввести льготы для производителей и установить фиксированные цены для покупателей.

Центральный банк публикует план цен на глазированные сырки на n nn дней, и все в стране его соблюдают.

Студент Дмитрий решил, что это отличный способ заработать. Он взял план и решил посчитать, сколько возможностей для увеличения капитала у него есть.

Пусть p ( d ) — это функция, которая определяет цену p  сырка в зависимости от дня d. Возможность для заработка возникает в ситуации, когда для дней x  и y  таких, что x < y  выполняется условие p ( x ) < p ( y ) p(x) < p(y)p(x)<p(y). Это означает, что Дмитрий может купить сырки в день x по более низкой цене и продать их в день y по более высокой цене, заработав на разнице.

Формат ввода В первой строке содержится натуральное число n nn — количество дней, на которое составлен план цен на сырки.

В следующих n nn строках содержится по одному натуральному числу p i p_ip i​— цена сырка в день i ii.

1 ≤ n ≤ 4000000 1 \leq n \leq 4 000 0001≤n≤4000000, 1 ≤ p i ≤ 200 1 \leq p_i \leq 2001≤p i​≤200

Формат вывода Выведите одно число — количество возможностей для заработка.

Пример 1

Ввод	
1
40
Вывод
0
Пример 2

Ввод	
3
40
50
60

Вывод
3
Пример 3

Ввод	
3
80
70
60

Вывод
0
Задача сводится к подсчёту количества пар (x, y), где x < y и цена в день x ниже цены в день y. Это классическая задача подсчёта пар, соответствующих правилу: цена в более ранний день меньше, чем в более поздний.

Основная идея:
Мы можем посчитать такие пары за один проход по массиву цен.
Каждому элементу, если он больше или равен предыдущему, мы не можем заработать на нем.
Если он больше предыдущего, то мы можем заработать на всех предыдущих меньших ценах, которые расположены перед этим элементом.
Однако, чтобы оптимально подсчитать такие пары, мы можем воспользоваться подсчётом количества меньших элементов, встречающихся ранее.

Решение:
Можно просто пройти по массиву цен слева направо.
Подсчитывать сумму всех величин, которые меньше текущего элемента (используя, например, структуру данных типа Fenwick Tree или сегментное дерево), чтобы за O(log n) подсчитывать сколько было меньших элементов или использовать просто накопительное подсчитывание, учитывая что цена ограничена до 200, что значительно упрощает задачу.
В данной задаче:
Цена варьируется от 1 до 200, что очень удобно.
Можно использовать массив подсчёта количества встреченных цен и для каждого текущего числа подсчитывать, сколько цен ниже него было ранее.
Реализация на Java с использованием массива подсчёта (поскольку p_i ≤ 200):

```java

import java.io.*;
public class PricePairs {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        int n = Integer.parseInt(br.readLine());
        int[] prices = new int[n];
        for(int i=0; i<n; i++) {
            prices[i] = Integer.parseInt(br.readLine());
        }

        long result = 0;
        int[] countPrices = new int[201]; // цены от 1 до 200

        for (int p : prices) {
            // считаем сколько было цен меньше текущей
            for (int v=1; v<p; v++) {
                result += countPrices[v];
            }
            // увеличиваем количество встретившихся цен p
            countPrices[p]++;
        }

        System.out.println(result);
    }
}
```
Объяснение:
Для каждого дня, цена которого равна p, мы суммируем все ранее встреченные цены, меньшие p.
Обновляем массив подсчёта цен.
После обработки всех цен, result содержит искомое число возможностей.
Компактность и эффективность:
Поскольку цены ограничены 200, это работает очень быстро, даже при n до 4 миллионов.
Время выполнения: O(n * 200), что приемлемо.
Если нужно — я могу помочь с более оптимизацией или пояснениями!

Лиза — селенитка, она живет на Луне и обожает фотографироваться. Она уже стала звездой всех лунных блогов и хотела бы, чтобы её фотографии стали популярны и на Земле. Но передать фотографии на Землю просто так не получается — отличается формат файлов. Но Лизе удалось узнать, какие участки лунной поверхности будет фотографировать спутник «Луна-26», и она хотела бы оказаться на всех этих кадрах!

Поверхность Луны, которая будет сфотографирована спутником, представляет собой прямоугольник, состоящий из W × H W \times HW×H одинаковых по размеру квадратов, нумерация квадратов идёт с левого нижнего угла и начинается с единицы. Спутник «Луна-26» сделает серию из N NN снимков через равные интервалы времени. Каждый снимок будет представлять собой подпрямоугольник, левая нижняя клетка которого имеет координаты X i L D , Y i L D X_{iLD}, Y_{iLD}X iLD​,Y iLD​, а правая верхняя — X i R U , Y i R U X_{iRU}, Y_{iRU}X iRU​,Y iRU​.

Лиза может подготовиться и перед началом съемок прийти в любой квадрат. За промежуток времени между снимками Лиза обязательно переместится в один из соседних по стороне квадратов — две фотографии из одного места подряд это не интересно, а уйти дальше чем на один квадрат она не успевает.

Определите, существует ли какой-нибудь маршрут Лизы, чтобы она попала на все снимки, или нет.

Формат ввода В первой строке задаются числа W WW и H HH (1 ≤ W , H ≤ 300 1 \le W, H \le 3001≤W,H≤300) — размеры поверхности Луны, над которой работает спутник.

Во второй строке записано число N NN — количество снимков, которое сделает спутник «Луна-26».

В следующих N NN строках записано по 4 числа X i L D , Y i L D , X i R U , Y i R U X_{iLD}, Y_{iLD}, X_{iRU}, Y_{iRU}X iLD​,Y iLD​,X iRU​,Y iRU​(1 ≤ X i L D ≤ X i R U ≤ W 1 \le X_{iLD} \le X_{iRU} \le W1≤X iLD​≤X iRU​≤W, 1 ≤ Y i L D ≤ Y i R U ≤ H 1 \le Y_{iLD} \le Y_{iRU} \le H1≤Y iLD​≤Y iRU​≤H) — координаты очередного снимка.

Формат вывода Выведите ”Yes”, если существует маршрут Лизы, и ”No” в противном случае.

Пример 1

Ввод	
4 2
5
2 1 2 2
2 1 2 2
1 1 2 1
2 1 2 1
2 2 3 2
Вывод
Yes
Пример 2

Ввод
2 2
2
1 1 1 1
2 2 2 2
Вывод
No
Примечания

В первом примере возможен такой маршрут Лизы:

2 2 — 2 1 — 1 1 — 2 1 — 2 2

Задача сводится к проверке существования маршрута перемещения Лизы по сетке, чтобы она могла быть в нужной ячейке в каждый момент времени.

Основная идея:
Маршрут Лизы — это последовательное перемещение между ячейками grid, где она может перемещаться только на соседние клетки за один шаг.
Каждая позиция Лизы должна попасть в одну из ячеек, входящих в область снимка, в соответствующий момент.
Кроме того, между двумя снимками у Лизы есть ограничение по времени — она может перемещаться только на соседние клетки за интервал времени между снимками.
Подход:
Для каждого снимка заданы области (подпрямоугольники).
Начальную позицию Лизы можно выбрать в любой ячейке области первого снимка.
Для каждого следующего снимка нужно проверить, возможен ли переход из области предыдущего снимка в область следующего — то есть существует ли ячейка, достижимая за заданное время.
Используя динамический подход или проверку достигимости из области в область, можно определить, существует ли такой маршрут.
Реализация:
Представим области снимков как наборы ячеек.
В процессеируем по снимкам, проверяя, можно ли перейти из областей предыдущего снимка к областям следующего, учитывая ограничения по времени.
Для ускорения достаточно сохранять границы (минимальную и максимальную координату X и Y) для каждой области, а затем проверить, возможно ли попасть из области на предыдущем снимке в область следующего за заданное количество шагов.
Реализация на Java:
```java

import java.io.*;

public class MoonRoute {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String[] firstLine = br.readLine().split(" ");
        int W = Integer.parseInt(firstLine[0]);
        int H = Integer.parseInt(firstLine[1]);

        int N = Integer.parseInt(br.readLine());

        int[][] regions = new int[N][4]; // X_LD, Y_LD, X_RU, Y_RU
        for (int i=0; i<N; i++) {
            String[] line = br.readLine().split(" ");
            regions[i][0] = Integer.parseInt(line[0]);
            regions[i][1] = Integer.parseInt(line[1]);
            regions[i][2] = Integer.parseInt(line[2]);
            regions[i][3] = Integer.parseInt(line[3]);
        }

        // Для каждого снимка нам нужно знать границы области, в которой может находиться Лиза
        int minX = regions[0][0], minY = regions[0][1], maxX = regions[0][2], maxY = regions[0][3];

        // Перебираем последовательно области
        for (int i=1; i<N; i++) {
            int prevMinX = minX, prevMinY = minY, prevMaxX = maxX, prevMaxY = maxY;

            int currMinX = regions[i][0], currMinY = regions[i][1], currMaxX = regions[i][2], currMaxY = regions[i][3];

            // Проверка на достижимость из области предыдущего снимка в текущую
            // по времени, то есть, можем ли мы попасть в текущую область за один шаг,
            // учитывая, что перемещение на соседнюю клетку за один шаг.

            // Область, в которой была Лиза на предыдущем снимке:
            // все клетки в диапазоне [prevMinX, prevMaxX] × [prevMinY, prevMaxY]
            // Область, в которую должна попасть Лиза:
            // клетки в диапазоне [currMinX, currMaxX] × [currMinY, currMaxY]

            // Расстояние перемещения между точками:
            // Минимальное возможное расстояние между любыми клетками из этих областей:
            // это Manhattan расстояние между крайними точками:
            int possible = Math.max(0, Math.max(
                Math.abs(prevMinX - currMaxX), Math.abs(prevMinY - currMaxY)
            ));

            // Но проще — чтобы попасть из любой ячейки в область предыдущего снимка
            // в любую ячейку в текущую, должно быть достаточно перейти, потому что
            // между ячейками можно перемещаться по 4 направлениям за один шаг.
            // Проверим, возможен ли переход за (i - (i-1)) шагов.

            int steps = i; // т.к. i — количество шагов (между снимками)
            // Проверим, что разница между областями по координатам позволяет это сделать.
            // Конкретная проверка:
            boolean canReach = false;

            // Есть ли точка в текущей области, которую можно добраться из области предыдущего?
            // Для этого проверим условие:
            // (maxX - minX) + (maxY - minY) <= steps * 2
            // однако проще проверить, существует ли пересечение расширенной области:
            // Расширенные границы предыдущей области, чтобы достигнуть текущей:
            int minXPrev = prevMinX - steps, maxXPrev = prevMaxX + steps;
            int minYPrev = prevMinY - steps, maxYPrev = prevMaxY + steps;

            // Проверяем пересечение:
            if (minXPrev <= currMaxX && maxXPrev >= currMinX &&
                minYPrev <= currMaxY && maxYPrev >= currMinY) {
                canReach = true;
            }

            if (!canReach) {
                System.out.println("No");
                return;
            }

            // Обновляем границы для следующего шага, чтобы в следующем цикле проверять
            minX = Math.max(1, currMinX);
            maxX = Math.min(W, currMaxX);
            minY = Math.max(1, currMinY);
            maxY = Math.min(H, currMaxY);
        }

        // Если все области достижимы последовательно, выводим "Yes"
        System.out.println("Yes");
    }
}
```
Краткая суть:
Проверяем, можно ли "перебежать" из области предыдущего снимка в текущую за i шагов.
Учитываем, что перемещение — на соседней клетке за шаг.
Если для хотя бы одного шага достижимость нарушается, выводим "No".
Иначе — "Yes".
Если нужно — могу помочь с более точным расчетом или проверить на конкретных данных!
